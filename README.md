Python Code Style Guide

# Питон
|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|
|[S1](#S1)|[S2](#S2)| [S3](#S3)| [S4](#S4)| [S5](#S5)| [S6](#S6)| [S7](#S7)| [S8](#S8)| [S9](#S9)| [S10](#S10)|  
|[S11](#S11)|[S12](#S12)| [S13](#S13)| [S14](#S14)| [S15](#S15)| [S16](#S16)| [S17](#S17)| [S18](#S18)| [S19](#S19)| [S20](#S20)|  
|[S21](#S21)|[S22](#S22)| [S23](#S23)| [S24](#S24)| [S25](#S25)| [S26](#S26)| [S27](#S27)| [S28](#S28)| [S29](#S29)| [S30](#S30)|  
|[S31](#S31)|[S32](#S32)| [S33](#S33)| [S34](#S34)| [S35](#S35)| [S36](#S36)| [S37](#S37)| [S38](#S38)| [S39](#S39)| [S40](#S40)|

# Логирование
|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|
|[L1](#L1)|[L2](#L2)| [L3](#L3)| [L4](#L4)| [L5](#L5)| [L6](#L6)| [L7](#L7)| [L8](#L8)| [L9](#L9)| [L10](#L10)|

# Функции
|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|
|[F1](#F1)|[F2](#F2)| [F3](#F3)| [F4](#F4)| [F5](#F5)| [F6](#F6)| [F7](#F7)| [F8](#F8)| [F9](#F9)| [F10](#F10)|




# Содержание

* [Порядок объявлений в модуле](#module-def-order)
* [Порядок объявлений в классе](#class-def-order)
* [Константы и конфигурация](#const-and-conf)
* [Глобальные переменные](#global-vars)
* [Naming](#naming)
  + [Классы](#naming-classes)
  + [Функции (методы класса)](#naming-functions)
  + [Переменные (свойства класса)](#naming-vars)
* [Описание публичных интерфейсов, документация](#interface-docs)
* [Type hinting](#type-hinting)
* [Работа со строками](#strings)
* [Закомментированный код](#commented-code)
* [Неиспользуемые переменные](#unused-vars)
* [Условные выражения](#conditions)
  + [Тернарный оператор](#conditions-ternary)
  + [Отрицательный контекст](#conditions-negative-ctx)
  + [Большие условия](#conditions-complex-stuff)
* [Свойства классов](#class-attrs)
* [True/False](#true-false)
* [filter, map, reduce](#filter-map-reduce)
* [Импорт](#import)
  + [Что импортировать](#import-what)
  + [Как импортировать](#import-how)
  + [Импорт в контексте пакета](#import-package-ctx)
  + [import *](#import-star)
* [Логирование](#logging)
* [Хорошие функции](#good-functions)

<a name="module-def-order"></a>
S0. Порядок объявлений в модуле
===========================

1. import
1. специальные переменные
1. константы
1. переменные
1. функции
1. классы

<a name="S1"></a> 
S1. Константы, переменные, функции и классы могут быть внутренними (internal, имя начинается с `_`) и публичными.
В этом случае внутри каждого блока также должен соблюдаться порядок - сначала внутренние, затем публичные.
Изменение порядка и смешивание разных блоков не допускается.

Исключение: допускается объявление переменных в конце модуля, если они вызывают функцию или создают объект класса, объявленные выше.

Пример:
```python
import requests

__all__ = ['THING_LIMIT', 'let_me_google_it_for_you', 'Anything']

_GOOGLE_URL = 'https://google.com'
THING_LIMIT = 10

_search_count = 0


def _get_search_url(term):
    return '{}?q={}'.format(_GOOGLE_URL, term)


def let_me_google_it_for_you(query):
    _search_count += 1
    response = requests.get(
        _get_search_url(query)
    )
    return response.text()


class _Something:
    pass


class Anything(_Something):
    pass
```

---

<a name="class-def-order"></a>
<a name="S2"></a>
S2. Порядок объявлений в классе
===========================

1. константы
1. свойства класса(поля)
1. `@property`
1. специальные методы класса
1. методы класса

<a name="S3"></a>
S3. Константы, свойства и методы класса могут быть внутренними (internal, имя начинается с `_`) и публичными.
В этом случае внутри каждого блока также должен соблюдаться порядок - сначала внутренние, затем публичные.
Изменение порядка и смешивание разных блоков не допускается.

Пример:
```python
class Anything:
    _APPLE = 1
    _BEEF = 2

    FRUIT = 'fruit'
    MEAT = 'meat'

    _default = FRUIT
    use_default = False

    @property
    def stuff(self):
        return None

    @stuff.setter
    def stuff(self, v):
        print(v)

    def __init__(self, thing):
        self._thing = thing or self._default

    def _transform(self):
        self._thing = next(thing for thing in [self.FRUIT, self.MEAT] if thing != self._thing)

    @staticmethod
    def blow_up():
        exit(2)
```

---

<a name="const-and-conf"></a>
Конфигурация
========================

<a name="S4"></a> 
S4. Все настройки, которые приложение получает извне(аргументы запуска, переменные окружения) - это конфигурация приложения. 
Конфигурация должна быть оформлена должным образом. Это м.б. файл config.py, либо другое решение, исполняемое 1 раз, при 
старте приложения, так чтобы в дальнейшем не было необходимости обращаться к извне. 
Нотификационные и конфигурационные события, изменяющие логику работы в райнтайме должны взаимодействовать с объектом конфигурации приложения, а не изменять его стартовое окружение.

<a name="S4.1"></a>
S4.1. Данные в .env файлах это строки содержащие пару атомарных значений: "КЛЮЧ"="ЗНАЧЕНИЕ" в верхнем регистре. 
Должны импортироваться и валидироваться ТОЛЬКО стандартными библиотеками. 
Самописный парсинг строковых значений не допускается. 
.env-файл - максимально глупая сущность.   

<a name="S5"></a>
S5. Для каждого параметра конфигурации должно быть значение по-умолчанию с возможностью его переопределить. 

<a name="S6"></a>
S6. Всё что приложение получает извне - переменные окружения, аргументы командной строки, должны быть описаны в файле README, в таблице "Параметры приложения", 
указываются: 
кодовое имя, назначение, пример значения(либо набор допустимых значений), тип значения,  
условия валидности, дефолтное значение, источник(args, env, vault), значимые примечания.  

Примеры параметров приложения:
* количество записей на странице
* лимиты и ограничения запросов, ответов
* длина генерируемых значений
* уровень логов, макс длина сообщения лога
* подключение к БД
* реквизиты доступа
* ключи
* токены
* адреса АПИ
* _и т.д._

---

<a name="global-vars"></a>
Глобальные переменные
=====================

<a name="S7"></a>
S7. Использование глобальных переменных не допускается.

---

<a name="naming"></a>
Naming
======

<a name="S8"></a> 
S8. Не следует выбирать бессмысленных имен, например `abc`, `x`, `temp` и пр.
Так же не следует сокращать названия (полностью или частично), например `e` или `el` вместо `element`.
Исключение: счетчики в циклах `for i, item in enumerate(items)` и list comprehension `objects = [x[0] for x in get_elements()]`

Список допустимых сокращений(не ухудшающих читаемость): 
* msg (message)
* elem(element)

Общее исключение:
в сложном коде, где имена переменных не влияют на читаемость(алгоритмы) нейминг произвольный.
Такие функции помечаются как #pylint: disable=invalid_name, либо другим коментарием

Стараться выбирать говорящие имена, но не слишком абстрактные (типа `manager`-ов и `helper`-ов), четко описывающие назначение функции или переменной.
Имя должно быть максимально коротким, ёмким и говорить о том, что делает функция\метод\класс\etc.
При этом не следует давать очень длинные названия. Если какие-то подробности в названии можно опустить и суть останется понятна - лучше их опустить.

<a name="S9"></a> 
S9. Избегать похожих имен, которые описывают совершенно разный функционал,либо затеняют builtins(что то вроде pass_, str_). 

<a name="naming-classes"></a>
### Классы
Классы абстрагируют действие либо объект, либо и то и другое(менеджеры).

<a name="S10"></a>
S10. Имя класса, абстрагирующего объект должно быть существительным и отвечать на вопрос `что?`
В общем случае - чем абстрактнее сущность тем абстрактнее и имя для класса сущности.
Account, Card, TableRow, Entry.   

<a name="S11"></a>
S11. Имя класса, абстрагирующего действие должно начинаться с глагола, содержать объект действия
и максимально точно отвечать на вопрос `что и с чем я делаю?` GetCardData, DelAccount

<a name="S12"></a>
S12. Имя класса, абстрагирующего и объект и действия над ним должно быть максимально коротким и при этом максимально понятным: ThreadPoolExecutor, PdfPrinter, TaxCalculator, ExcelClient 

<a name="naming-functions"></a>
### Функции (методы класса)

<a name="S13"></a>
S13. Функции выполняют какое-либо действие, причем только одно, и их название начинается с глагола и описывает совершаемое действие: `get_key`, `configure`, `login`
Так же они могут выполнять какую-либо проверку, в таком случае их название должно подразумевать однозначный ответ на вопрос (да\нет) и начинаться с `is`, `has`, `can`, `does` и т.п.

> Если не получается придумать короткое и ёмкое название для функции, то скорее всего она делает гораздо больше, чем следует.
Возможно, следует заняться рефакторингом и разбить её на функции поменьше.

<a name="S14"></a>
S14. Не допускается использовать отрицательный контекст в нейминге. Например IsNotValid(нужно IsValid) 

<a name="naming-vars"></a>
### Переменные (свойства класса)

<a name="S15"></a>
S15. Если переменная содержит значение булева типа, то её название так же должно подразумевать однозначный ответ на вопрос (да\нет) и начинаться с `is`, `has`, `can`, `does` и т.п.

---

<a name="interface-docs"></a>
Описание публичных интерфейсов
==============================

<a name="S16"></a>
S16. Все публичные классы, методы и функции должны иметь описание на русском языке в докстринге.

<a name="S17"></a>
S17. Докстринг - это строка максимально короткая и максимально понятная, на русском языке.

<a name="S18"></a>
S18. Не допускается описывать конкретную реализацию (каким именно образом решается проблема).

<a name="S19"></a>
S19. Шаблон докстринга для повторно используемого кода, РАСПРОСТРАНЯЕМОГО КАК ПИТОН ПАКЕТЫ.
В описании должно быть:
* Назначение (какую проблему решает этот класс\функция)
* Примеры использования (опционально)
* Описание аргументов, которые принимает функция или конструктор класса
* Исключения, которые могут быть выброшены в процессе работы функции
* Результат (или возвращаемое значение)
```
def do_something(param1: int, param2: str) -> bool:
    """
    Назначение. Какую проблему решает?

    Args:
        param1: Первый параметр. Принимаер разные значения, например:
            1: Число. Первое после нуля.
            2: Должно быть понятно.
            `SOME_CONSTANT`: Когда не понятно, но очень надо.
        param2: Второй параметр.

    Raises:
        ValueError: Некорректное значение param1.
         CustomException: Есть свои причины.

    Returns:
        Описание возвращаемого значения.

    [опционально]Example:
        ```something = do_something(param1, param2)```

    """
```

---

<a name="type-hinting"></a>
Type hinting
============

<a name="S20"></a>
S20. [PEP 484](https://www.python.org/dev/peps/pep-0484) (классы и функции) - применяется везде согласно спецификации.
Уточнение 1:
Версия 3.9 допускает использование в качестве хинтов простых типов - классов встроенных типов(dict, tuple и др.).
Для единого стиля хинтов использовать только типы из Typing.

Недопустимо:
```python
def f(a: dict):
    pass
```
Нужно:
```python
def f(a: Dict):
    pass
```

<a name="S21"></a>
S21. [PEP 526](https://www.python.org/dev/peps/pep-0526) (переменные) - не обязательно и применяется на усмотрение разработчика.

Недопустимо:
```python
def f(a):
    pass
```

Плохо:
```python
from typing import Text, Union

def f(a: Text):
    pass
```

```python
import typing

def f(a: typing.Text):
    pass
```

Хорошо:
```python
from typing import *

def f(a: Text):
    pass
```

Отлично:
```python
from typing import *

def check_text(a: Text) -> Bool:
    pass
```
---

<a name="strings"></a>
Работа со строками
==================

<a name="S22"></a>
S22. В приоритете использовать f-строки.
Форматировать строки через `str.format` предпочтительнее, чем через `%`.
Но делать это следует только тогда, когда есть необходимость подставить значения в шаблон.

<a name="S23"></a>
S23. Для конкатенации строк использовать оператор `+`, когда их 2, если больше - `str.join`

Плохо:
```python
value = '{}{}{}'.format(x, y, z)
print('I %s code review!' % 'love' if True else 'hate')
```

Хорошо:
```python
requests.get('http://my.api.com' + '/handle', params)
value = ''.join([x, y, z])
print('I {} code review!'.format('love' if True else 'hate'))
# or
print(f'I {value} code review!')
```

---

<a name="commented-code"></a>
Закомментированный код
======================

<a name="S24"></a>
S24. В коде MR не должно быть ни одной строчки закомментированного кода.
Все что не нужно - должно быть удалено - в т.ч. коментарии, поясняющие понятный код, ToDo.
Если хочется оставить что-то для примера, то лучше вынести это в описание в docstring.
Чтобы не забыть что то(ToDo) - можно испльзовать закладки в IDE
Примечание: это не про комментарии к коду, их можно.

Допускается использовать коментарии, визуально отделяющие И ОПИСЫВАЮЩИЕ начало какой-либо группы функций класса/модуля. 
Цель - облегчить ориентацию в большом количестве функций.
(например #=================== взаимодействие с брокером ======================).


---

<a name="unused-vars"></a>
Неиспользуемые переменные
=========================

<a name="S25"></a>
S25. Когда функция возвращает больше значений, чем нужно (то есть они не будут использоваться в коде), не следует давать названия переменным с такими значениями.

Плохо:
```python
a, b, c = get_names()
```

Лучше:
```python
a, _, __ = get_names()
```

Совсем хорошо:
```python
a, *_ = get_names()
```

---

<a name="S26"></a>
S26. Не допускается использование _ как параметра в сигнатуре функции. 

Недопустимо:
```python
def check_text(_: Str, __:Bool) -> Bool:
    pass
```
Допустимо:
```python
from utils import my_util_fn as _ 
```

<a name="conditions"></a>
Условные выражения
==================

<a name="conditions-ternary"></a>
### Тернарный оператор

<a name="S27"></a>
S27. Вариант записи через тернарный условный оператор является более предпочтительным.

Плохо:
```python
if user.has_name():
    x = 5
else:
    x = 0
```

Хорошо:
```python
x = 5 if user.has_name() else 0
```

<a name="conditions-negative-ctx"></a>
### Отрицательный контекст

<a name="S28"></a>
S28. Проверяемые перeменные и функции не должны оперировать отрицательным
контекстом.

Плохо:
```python
has_no_accounts = len(User.accounts) == 0
if has_no_accounts:
    pass
```

Хорошо:
```python
has_accounts = bool(User.accounts)
if not has_accounts:
    pass
```

<a name="conditions-complex-stuff"></a>
### Большие условия

<a name="S29"></a>
S29. Когда требуется проверка большого количества условий и\или некоторых
вычислений, следует разбивать условия на логические группы и давать
им говорящие имена.

Плохо:
```python
if ((user.is_admin or user.can_access()) and (len(sections) or items)) or config.get('force_show', False):
    pass
```

Хорошо:
```python
can_access = user.is_admin or user.can_access()
page_is_empty = not sections and not items
force_show = config.get('force_show', False)

if (can_access and not page_is_empty) or force_show:
    pass
```

---

<a name="class-attrs"></a>
Свойства классов
================

<a name="S30"></a>
S30. Не использовать геттеры и сеттеры для свойств класса, а объявлять их публично.
В случае, когда нужны вычисления, использовать декоратор `@property`.

Плохо:
```python
class Something:
     _x = 0
    _anything = None

    def set_anything(self, v):
        self._anything = v

    def get_anything(self):
        return self._anything

    def set_x(self, v):
        self._x = v * 2

    def get_x(self):
        return self._x
```

Хорошо:
```python
class Something:
    _x = 0
    anything = None

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, v):
        self._x = v * 2
```

---

<a name="true-false"></a>
True/False
==========

<a name="S31"></a>
S31. Использовать явные приведения к булеву типу там, где это необходимо(т.е чтобы кастовать только в одном месте).

Плохо:
```python
class Box:
    things = []

    def has_something(self):
        return self.things
```

Хорошо:
```python
class Box:
    things = []

    def has_something(self):
        return bool(self.things)
```

---

<a name="filter-map-reduce"></a>
filter, map, reduce
===================

<a name="S32"></a>
S32. Плохо читаемые конструкции, от которых предпочтительнее отказаться в пользу list\dict comprehension.

Плохо:
```python
map(lambda x: x[1], filter(lambda x: x[2] == 5, my_list))
```

Хорошо:
```python
[item[1] for item in my_list if item[2] == 5]
```

---

<a name="import"></a>
Импорт
======

Структура проекта для справки:
```
app/
 |- __init__.py
 |- main.py
my_package
 |- __init__.py
 |- my_module.py
 |- utils.py
```

<a name="import-what"></a>
### Что импортировать

<a name="S33"></a>
S33. В приоритете импортировать только пакеты или модули. 
Допустимо импортировать классы, функции и переменные напрямую с ограничением:
такой импорт занимает не более 5 строк, либо 10 имен. 
Недопустимо импортировать неявным образом (`from module import *`).

    Исключение: для модуля `typing` допускается делать `from typing import *` или импортировать классы напрямую `from typing import Type, AnotherType`

Плохо:
```python
from datetime import datetime, timedelta  # импорт классов
from decimal import Decimal
from urllib import parse

datetime.now() - timedelta(days=7)
parse.url_parse('http://www.ru/url')
```

Хорошо:
```python
import datetime  # импорт модуля
import decimal
import urllib.parse

datetime.datetime.now() - datetime.timedelta(days=7)
urllib.parse.url_parse('http://www.ru/url')
```

<a name="import-how"></a>
### Как импортировать

<a name="S34"></a>
S34. При импорте использовать только абсолютные пути.

app/main.py:
```python
import my_package
# или
import my_package.my_module
```

<a name="S35"></a>
S35. В случае, когда у импортируемого модуля\пакета получается очень длинный путь, допускается сокращать пути с сохранением смысла используя конструкцию `import as`.
Сокращенное название по-прежнему должно давать четкое понимание что это за модуль и откуда оно взялось. Для этого следует составлять новое название из компонентов полного пути (обычно первый+последний, иногда вставляются промежуточные для большей ясности).

Например:
```python
import django.db.models as django_models
import django.core.management.commands.flush as django_commands_flush
```

<a name="import-package-ctx"></a>
### Импорт в контексте пакета

<a name="S36"></a>
S36. При импорте собственных модулей внутри пакета использовать конструкцию `from root.package import submodule`,
где `root.package` - полный путь до пакета, `submodule` - модуль этого пакета.

my_package/my_module.py:
```python
from my_package import utils
```

<a name="import-star"></a>
### import *

<a name="S37"></a>
S37. Допускается использовать конструкцию `from package.submodule import *` **_только_** в `__init__.py`
При этом импортируемый модуль должен описывать свой публичный интерфейс в переменной `__all__`

> Используйте этот подход для определения простых и понятных интерфейсов,
чтобы избегать длинных цепочек импорта: `import masterpiece.xyz.contrib.that_lib.awesome_feature`

app/my_package/\_\_init__.py:
```python
from my_package.my_module import *
```

my_package/my_module.py:
```python
__all__ = ['MyClass']

def _do_stuff():
    pass

class MyClass:
    pass
```

<a name="logging"></a>
### Логирование
[по мотивам](https://medium.com/nuances-of-programming/%D0%BF%D1%80%D0%BE%D1%84%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4-%D0%BA-%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8E-%D0%BB%D0%BE%D0%B3%D0%BE%D0%B2-63bd0c02950)

Что записывать в лог ?
Программа — это серия переходов между состояниями.
Состояния — это вся информация, которую программа хранит в своей памяти в определенный момент времени, а код программы определяет то, как она переходит от одного состояния к другому. 
Логи должны содержать информацию, необходимую для реконструкции переходов состояний.
Невозможно, да и не нужно, фиксировать все состояния во все отрезки времени.

Кто должен записывать логи?
Типичная ошибка, связана с тем, “кто” должен фиксировать информацию. 
Ведение логов не теми функциями оборачивается дублированием или дефицитом информации.

<a name="L1"></a>
L1. Лог должен быть значимым. 

Хорошо:
```python
logger.info("start rest handler process")
logger.info(f"reconnecting to database, attemp{cnt}, next after {rec_interval} sec")
```

Плохо:
```python
logger.info("in get_data function")
logger.info(f"{meaningful_var=}")
```
при логгировании в режиме debug следует помнить о том что значительный вывод в логи это блокирующая операция,
которая влияет на общую производительность, а в случае асинхронных программ влияет и на порядок исполнения корутин. 

<a name="L2"></a>
L2. Лог должен содержать контекст - модуль, время, другие значимые данные о состоянии. 
Для вывода модуля при логировании в проде разумно использовать уникальные в рамках проекта сокращения [TL][MPR] минимальной длины
Формирование таких акронимов можно делать авотматически, в классе логгера, используя маппинг по значению переменной module

<a name="L3"></a>
L3. Лог должен быть структурирован и располагаться на разных, соответствующих уровнях.

логгируем на неправильном уровне - код элементарных функций становится сложнее чем должен быть.

Неправильно:
```python

def validateSSN(ssn: Str): 
  
  regex = "^(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-?!0000)[0-9]{4}$"
  pattern = re.compile(regex)
  matcher = pattern.matcher(ssn)

  if !matcher.matches():    
    logger.info("Bad SSN blah, blah, blah...")
    raise ValidationException("expecting SSN format AAA-GG-SSSS but got %s", ssn.replaceAll("\\d", "*"))
```

отправлять сообщения в лог нужно в том месте, которое обладает всем значимым контекстом.
Правильно:
```python
def validateUserUpdateRequest(UserUpdateRequest req): {
    ... проверка другого атрибута req 
 
    try:
       validateSSN(req.ssn);
    except ValidationException as exc:        
       logger.info("Received a user update request(track id %s) from user uuid %s, rejecting it because %s", req.trackID, req.uid, e.getMessage()));
       ... другая логика обработки ошибки ...

```

<a name="L4"></a>
L4. Лог должен быть сбалансированным: он не должен содержать слишком мало или слишком много информации. 

<a name="L5"></a>
L5. Лог должен быть форматированным: регистрация сообщений должна быть понятна людям и просто разбираться машинами.

<a name="L6"></a>
L6. Лог в сложных приложениях должен вестись в несколько файлов журнала.

<a name="L7"></a>
L7. Лог должен иметь стратегию ротации.

<a name="L8"></a>
L8. Лог должен быть адаптирован к разработке и продакшену.

<a name="L9"></a>
L9. Сообщение продакшен лога должно быть максимально коротким и информативным.

<a name="good-functions"></a>
### Хорошие функции
[по мотивам](https://habr.com/ru/company/piter/blog/426381/)

<a name="F1"></a>
F1. Внятное название. Максимально короткое и максимально понятное.

У разработчика вообще не знакомого с кодом, **только из названия** должно сложиться первичное понимание назначения ф-ии. 
Чем выше вероятность того что это первичное понимание верное - тем правильнее названа функция.
(В идеале: дворник к-й изучал английский в школе - без проблем переводит название функции и дает пояснения по возможной реализации).

<a name="F2"></a>
F2. Соответствует принципу единственной обязанности.


<a name="F3"></a>
F3. Сигнатура оформлена по [PEP 484](https://www.python.org/dev/peps/pep-0484)

<a name="F4"></a>
F4. Содержит докстроку на русском языке. 
Про докстроки смотреть [S16](#S16), [S19](#S19) 

<a name="F5"></a>
F5. Состоит не более чем из 50 строк. Исключение - чисто алгоритмические истории [например](https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%BE%D0%B9_%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8)

<a name="F6"></a>
F6. Она идемпотентная и, если это возможно, чистая

<a name="F7"></a>
F7. Максимальное суммарное(включая декораторы декораторов) кол-во декораторов конкретной функции - 2.
Первый декоратор - каким либо образом группирует функции клиентского кода, Второй - про модификацию поведения.  

<a name="F8"></a>
F8. В случаях когда это позволяет понизить вложенность кода(число отступов) - функции должны следовать [early return pattern](https://habr.com/ru/post/348074/) - 
стратегии, когда функция возвращает результат сразу же, а не в конце, 
